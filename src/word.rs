extern crate env_logger;
extern crate log;
use log::info;

const CHR_A : u8 = 'a' as u8;
const CHR_B : u8 = 'b' as u8;

const SQRT_5 : f64 = 2.23606797749978969641; //(5.0 as f64).sqrt();
const GOLDEN_RATIO : f64 = (1.0 + SQRT_5)/2.0;
const PSI : f64 = - 1.0/GOLDEN_RATIO;


pub fn fibonacci_number(k: u8) -> usize {
	if k == 0 {
		return 1;
	}

	let [mut sum, mut cur, mut old] = [1,1,0];
	// let mut last = 0;
	// let mut curr = 1;
	for _ in 0..k+1 {
        sum = cur + old;
        old = cur;
        cur = sum;
	}
	sum
}

/// Estimates the k-th Fibonacci number with Binet's formula
fn fibonacci_number_estimate(k : u8) -> f64 {
    (GOLDEN_RATIO.powi(k as i32) - PSI.powi(k as i32))/SQRT_5
}

/// Computes the k-th Fibonacci word
/// https://oeis.org/A003849
/// Reference: Patrice Séébold: "Sequences generated by infinitely iterated morphisms". Discret. Appl. Math. 11(3): 255-264 (1985)
pub fn fibonacci_word(k : u8) -> Vec<u8> {
    let length = (fibonacci_number_estimate(k+2)+1.0) as usize + 1;
    let mut text : Vec<u8> = Vec::with_capacity(length);
    unsafe { text.set_len(length); }
    info!("allocate text length = {}", length);
    text[0] = CHR_A;

    let mut previous_fibonacci_number = 0;
    let mut current_fibonacci_number = 1; //@ stores in the end the k-th Fibonacci number
    let mut source = 0; //@ pointer in `text` where to read the next input character
    let mut target = 1; //@ pointer in text where to write the next output character

    for _ in 0..k+1 { //@ counts for each fibonacci number
        let new_fibonacci_number = current_fibonacci_number + previous_fibonacci_number;
        while target < new_fibonacci_number {
            if text[source] == CHR_A {
                text[target] = CHR_B;
                text[target+1] = CHR_A;
                target += 2;
            } else {
                text[target] = CHR_A;
                target += 1;
            }
            source += 1;
        }
        previous_fibonacci_number = current_fibonacci_number;
        current_fibonacci_number = new_fibonacci_number;
        info!("{}", current_fibonacci_number);
    }
    info!("{}-th fibonacci number = {}", k, current_fibonacci_number);
    info!("written characters = {}", target);
    text.truncate(current_fibonacci_number);
    return text
}

#[test]
fn test_fibonacci() {
    assert_eq!(b"a"                     , fibonacci_word(0).as_slice());
    assert_eq!(b"ab"                    , fibonacci_word(1).as_slice());
    assert_eq!(b"aba"                   , fibonacci_word(2).as_slice());
    assert_eq!(b"abaab"                 , fibonacci_word(3).as_slice());
    assert_eq!(b"abaababa"              , fibonacci_word(4).as_slice());
    assert_eq!(b"abaababaabaab"         , fibonacci_word(5).as_slice());
    assert_eq!(b"abaababaabaababaababa" , fibonacci_word(6).as_slice());
}
#[test]
fn test_fibonacci_number() {
    assert_eq!( 1  , fibonacci_number(0));
    assert_eq!( 2  , fibonacci_number(1));
    assert_eq!( 3  , fibonacci_number(2));
    assert_eq!( 5  , fibonacci_number(3));
    assert_eq!( 8  , fibonacci_number(4));
    assert_eq!( 13 , fibonacci_number(5));
    assert_eq!( 21 , fibonacci_number(6));
    assert_eq!( 34 , fibonacci_number(7));
    assert_eq!( 55 , fibonacci_number(8));
    assert_eq!( 89 , fibonacci_number(9));
    assert_eq!( 144, fibonacci_number(10));
    for k in 0..16 {
        assert_eq!(fibonacci_word(k).len(), fibonacci_number(k));
    }
}


/// algorithm computing the i-th Thue-Morse sequence
/// https://oeis.org/A010060
/// It uses the fact that 
/// a) TM_k = TM_k-1 \bar{TM_k-1}
/// b) TM_k is a prefix of TM_{k+1}
pub fn thuemorse_word(i : u8) -> Vec<u8> {
    let n = 1<<i;
    let mut str : Vec<u8> = Vec::with_capacity(n);
    unsafe { str.set_len(n); }
    str[0] = CHR_A;
    for j in 0..i {
        let powerj = 1<<j;
        for k in 0..powerj {
            str[powerj+k] = if str[k] == CHR_A { CHR_B } else { CHR_A }; 
        }
    }
    return str
}

#[test]
fn test_thuemorse_word() {
    assert_eq!(b"a"                , thuemorse_word(0).as_slice());
    assert_eq!(b"ab"               , thuemorse_word(1).as_slice());
    assert_eq!(b"abba"             , thuemorse_word(2).as_slice());
    assert_eq!(b"abbabaab"         , thuemorse_word(3).as_slice());
    assert_eq!(b"abbabaabbaababba" , thuemorse_word(4).as_slice());
}


/// upper bound on the length of the k-th kolakoski word
fn kolakoski_length_estimate(k : u8) -> f64 {
    (2.0f64).powi(k as i32)
}

/// Computes the k-th Kolakoski word starting with 22
/// https://oeis.org/A078880
pub fn kolakoski_word(k : u8) -> Vec<u8> {
    let length = (kolakoski_length_estimate(k+2)+1.0) as usize + 1;
    let mut text : Vec<u8> = Vec::with_capacity(length);
    unsafe { text.set_len(length); }
    info!("allocate text length = {}", length);
    text[0] = CHR_B;
    text[1] = CHR_B;

    // let mut previous_number = 2;
    // let mut current_number = 1; //@ stores in the end the k-th Fibonacci number
    let mut source = 1; //@ pointer in `text` where to read the next input character
    let mut target = 2; //@ pointer in text where to write the next output character
    let mut current_size = 2;
    let mut old_size = 0;

    for _ in 0..k { //@ counts for each fibonacci number
        loop {
            let current_symbol = if text[target-1] == CHR_A { CHR_B } else { CHR_A };
            if text[source] == CHR_A {
                text[target] = current_symbol;
                target+=1;
            }
            if text[source] == CHR_B {
                text[target] = current_symbol;
                text[target+1] = current_symbol;
                target+=2;
            }
            source += 1;
            if source == current_size {
                current_size = old_size+target;
                old_size = current_size-target;
                break;
            }
        }
    }
    unsafe { text.set_len(target); }
    return text
}

#[test]
fn test_kolakoski() {
    // from https://oeis.org/A078880
	let prefix = [CHR_B,CHR_B,CHR_A,CHR_A,CHR_B,CHR_A,CHR_B,CHR_B,CHR_A,CHR_B,CHR_B,CHR_A,CHR_A,CHR_B,CHR_A,CHR_A,CHR_B,CHR_B,CHR_A,CHR_B,CHR_A,CHR_A,CHR_B,CHR_A,
 CHR_B,CHR_B,CHR_A,CHR_A,CHR_B,CHR_A,CHR_A,CHR_B,CHR_A,CHR_B,CHR_B,CHR_A,CHR_B,CHR_B,CHR_A,CHR_A,CHR_B,CHR_A,CHR_B,CHR_B,CHR_A,CHR_B,CHR_A,CHR_A,CHR_B,
 CHR_A,CHR_A,CHR_B,CHR_B,CHR_A,CHR_B,CHR_B,CHR_A,CHR_A,CHR_B,CHR_A,CHR_B,CHR_B,CHR_A,CHR_B,CHR_B,CHR_A,CHR_A,CHR_B,CHR_A,CHR_A,CHR_B,CHR_A,CHR_B,CHR_B,
 CHR_A,CHR_B,CHR_A,CHR_A,CHR_B,CHR_B,CHR_A,CHR_B,CHR_B,CHR_A,CHR_A,CHR_B,CHR_A,CHR_B,CHR_B,CHR_A,CHR_B,CHR_B,CHR_A,CHR_A,CHR_B,CHR_A,CHR_A,CHR_B,CHR_B,
 CHR_A,CHR_B,CHR_A,CHR_A,CHR_B,CHR_A];

	for i in 0.. { 
		let s = kolakoski_word(i);
        if s.len() > prefix.len() { break; }
        assert_eq!(s.as_slice(), &prefix[0..s.len()]);

	}
}


static STR_AB: &'static [u8] = &[CHR_A, CHR_B];
static STR_AA: &'static [u8] = &[CHR_A, CHR_A];
static STR_BA: &'static [u8] = &[CHR_B, CHR_A];

/// morphism for the Period-doubling sequence
/// https://oeis.org/A096268
fn period_doubling_morphism(c : u8) -> &'static[u8] {
    match c {
        CHR_A => STR_AB,
        _ => STR_AA,
    }
}

pub fn thuemorse_morphism(c : u8) -> &'static[u8] {
    match c {
        CHR_A => STR_AB,
        _ => STR_BA,
    }
}

fn iterate_morphism(rounds : u8, morphism: fn(u8) -> &'static[u8]) -> Vec<u8> {
    if rounds == 0 {
        return vec!(CHR_A);
    }
    let n = 1<<(rounds);
    let mut text : Vec<u8> = Vec::with_capacity(n);
    unsafe { text.set_len(n); }
    text[0] = CHR_A;
    text[1] = CHR_B;
    let mut source_pos = 1;
    let mut target_pos = 2;
    while target_pos < n {
        for c in morphism(text[source_pos]) {
            text[target_pos] = *c;
            target_pos += 1;
            if target_pos == n { break; }
        }
        source_pos += 1;
    }
    return text
}

pub fn period_doubling_word(k : u8) -> Vec<u8> {
    iterate_morphism(k, period_doubling_morphism)
}

#[test]
fn test_thue_morse_morphism() {
    for k in 0..10 {
        assert_eq!(thuemorse_word(k), iterate_morphism(k, thuemorse_morphism).as_slice());
    }
}

#[test]
fn test_perioddoubling() {
    assert_eq!(b"a"                                , iterate_morphism(0 , period_doubling_morphism).as_slice());
    assert_eq!(b"ab"                               , iterate_morphism(1 , period_doubling_morphism).as_slice());
    assert_eq!(b"abaa"                             , iterate_morphism(2 , period_doubling_morphism).as_slice());
    assert_eq!(b"abaaabab"                         , iterate_morphism(3 , period_doubling_morphism).as_slice());
    assert_eq!(b"abaaabababaaabaa"                 , iterate_morphism(4 , period_doubling_morphism).as_slice());
    assert_eq!(b"abaaabababaaabaaabaaabababaaabab" , iterate_morphism(5 , period_doubling_morphism).as_slice());
}



const CHR_C : u8 = 'c' as u8;
const CHR_D : u8 = 'd' as u8;

const CHR_ZERO : u8 = '0' as u8;
const CHR_ONE : u8 = '1' as u8;

pub fn paperfolding_word(i : u8) -> Vec<u8> { quaternary_to_binary(&quaternary_paperfolding_word(i)) }

/// algorithm computing the i-th paperfolding sequence
/// https://oeis.org/A014577
/// where a = 00, b = 01, c = 10, d = 11
pub fn quaternary_paperfolding_word(i : u8) -> Vec<u8> {
    let n = 1<<i;
    let mut str : Vec<u8> = Vec::with_capacity(n);
    unsafe { str.set_len(n); }
    str[0] = CHR_D;

    for k in 0..(n>>1){
        let target_position = 2*k;
        match str[k] {
            CHR_D => {
                str[target_position] = CHR_D;
                str[target_position+1] = CHR_B;
            },
            CHR_B => {
                str[target_position] = CHR_C;
                str[target_position+1] = CHR_B;
            },
            CHR_C => {
                str[target_position] = CHR_D;
                str[target_position+1] = CHR_A;
            },
            CHR_A => {
                str[target_position] = CHR_C;
                str[target_position+1] = CHR_A;
            }
            _ => panic!("unknown sequence : {} at position {}", str[k], k)
        }
    }

    return str
}

#[test]
fn test_paperfolding() {
    assert_eq!(b"d"            , quaternary_paperfolding_word(0).as_slice());
    assert_eq!(b"db"           , quaternary_paperfolding_word(1).as_slice());
    assert_eq!(b"dbcb"         , quaternary_paperfolding_word(2).as_slice());
    assert_eq!(b"dbcbdacb"     , quaternary_paperfolding_word(3).as_slice());
    
    let mut l = paperfolding_word(10);
    l.resize(99,0);
    assert_eq!(b"110110011100100111011000110010011101100111001000110110001100100111011001110010011101100011001000110", l.as_slice());
   // [0..100] );
}

fn quaternary_to_binary(text : &[u8]) -> Vec<u8> {
    let n = text.len()<<1;
    let mut output : Vec<u8> = Vec::with_capacity(n);
    unsafe { output.set_len(n); }
    for i in 0..text.len() {
        match text[i] {
            CHR_D => {
                output[2*i] = CHR_ONE;
                output[2*i+1] = CHR_ONE;
            },
            CHR_B => {
                output[2*i] = CHR_ZERO;
                output[2*i+1] = CHR_ONE;
            },
            CHR_C => {
                output[2*i] = CHR_ONE;
                output[2*i+1] = CHR_ZERO;
            },
            CHR_A => {
                output[2*i] = CHR_ZERO;
                output[2*i+1] = CHR_ZERO;
            }
            _ => panic!("unknown sequence : {} at position {}", text[i], i)
        }
    }
    output
}

/// checks whether T[1..n] is a necklace, i.e., the lexicographically smallest string among all its
/// shifted conjugates of the form T[i+1..n]T[1..i]
pub fn is_necklace<T>(text: &T, n : usize) -> bool 
where
T: ?Sized + std::ops::Index<usize, Output = u8>,
{
    // let n = text.len();
    let mut i = 0;
    let mut j = 1;
    while j != n && text.index(i) <= text.index(j) {
        if text.index(i) < text.index(j) {
            i = 0;
        }
        if text.index(i) == text.index(j) {
            i += 1;
        }
        j += 1;
    }
    if j != n { return false; }
    return true;
}


#[allow(dead_code)]
fn is_necklace_slice(text: &[u8]) -> bool {
    is_necklace(text, text.len())
}

#[test]
fn test_is_necklace() {
    assert!(is_necklace_slice(b"a"));
    assert!(is_necklace_slice(b"aa"));
    assert!(is_necklace_slice(b"ab"));
    assert!(is_necklace_slice(b"aaa"));
    assert!(is_necklace_slice(b"aba"));
    assert!(is_necklace_slice(b"aaba"));
    assert!(is_necklace_slice(b"abab"));
    assert!(is_necklace_slice(b"ababa"));
    assert!(!is_necklace_slice(b"ba"));
    assert!(!is_necklace_slice(b"bab"));
    assert!(!is_necklace_slice(b"bba"));
    assert!(!is_necklace_slice(b"bbba"));
}

fn reverse(c : u8) -> u8 {
    if c == CHR_A  { CHR_B }
    else { CHR_A }
}

/// Online construction algorithm of
/// J. Sawada, A. Williams and D. Wong. A surprisingly simple de Bruijn sequence
/// construction. Discrete Math., 339(1):127--131, 2016.
pub fn binary_debruijn_word(k : u8) -> Vec<u8> {
    use std::collections::VecDeque;
    let n = k as usize + 1;
    let mut word: VecDeque<u8> = VecDeque::with_capacity(n);
    for _ in 0..n {
        word.push_back(CHR_A);
    }
    let mut output : Vec<u8> = Vec::with_capacity(n);
    loop {
        let mut first_char = word.pop_front().unwrap();
        word.push_back(CHR_B);
        if is_necklace(&word, word.len()) {
            first_char = reverse(first_char);
        }
        *word.back_mut().unwrap() = first_char;
        output.push(first_char);
        for i in 0..n {
            if word[i] == CHR_B {
                break;
            }
            if i == n-1 {
                return output;
            }
        }
    }
}

/// The k-th binary de-Brujin sequence has a length of 2^{k+1}, and each substring of length k+1 is
/// has a nuique occurrence
#[test]
fn test_binary_debrujin_word() {
    use std::str;

    for k in 2..10 {
        let word = binary_debruijn_word(k);
        let text = str::from_utf8(&word).unwrap();
        for pos in 0..word.len()-k as usize {
            let pattern = str::from_utf8(&word[pos..pos+1+k as usize]).unwrap();
            assert!(text[pos+1..].find(pattern) == None);
        }
    }
}


