extern crate env_logger;
extern crate log;
use log::info;

const CHR_A: u8 = b'a';
const CHR_B: u8 = b'b';

#[allow(clippy::excessive_precision)]
const SQRT_5: f64 = 2.23606797749978969641; //(5.0 as f64).sqrt();
const GOLDEN_RATIO: f64 = (1.0 + SQRT_5) / 2.0;
const PSI: f64 = -1.0 / GOLDEN_RATIO;

pub fn fibonacci_number(k: u8) -> usize {
    if k == 0 {
        return 1;
    }

    let [mut sum, mut cur, mut old] = [1, 1, 0];
    for _ in 0..k + 1 {
        sum = cur + old;
        old = cur;
        cur = sum;
    }
    sum
}

/// Estimates the k-th Fibonacci number with Binet's formula
fn fibonacci_number_estimate(k: u8) -> f64 {
    (GOLDEN_RATIO.powi(k as i32) - PSI.powi(k as i32)) / SQRT_5
}

/// Computes the k-th Fibonacci word
/// https://oeis.org/A003849
/// Reference: Patrice Séébold: "Sequences generated by infinitely iterated morphisms". Discret. Appl. Math. 11(3): 255-264 (1985)
pub fn fibonacci_word(k: u8) -> Vec<u8> {
    let length = (fibonacci_number_estimate(k + 2) + 1.0) as usize + 1;
    let mut text = vec![0_u8; length];
    // let mut text : Vec<u8> = Vec::with_capacity(length);
    // unsafe { text.set_len(length); }
    info!("allocate text length = {}", length);
    text[0] = CHR_A;

    let mut previous_fibonacci_number = 0;
    let mut current_fibonacci_number = 1; //@ stores in the end the k-th Fibonacci number
    let mut source = 0; //@ pointer in `text` where to read the next input character
    let mut target = 1; //@ pointer in text where to write the next output character

    for _ in 0..k + 1 {
        //@ counts for each fibonacci number
        let new_fibonacci_number = current_fibonacci_number + previous_fibonacci_number;
        while target < new_fibonacci_number {
            if text[source] == CHR_A {
                text[target] = CHR_B;
                text[target + 1] = CHR_A;
                target += 2;
            } else {
                text[target] = CHR_A;
                target += 1;
            }
            source += 1;
        }
        previous_fibonacci_number = current_fibonacci_number;
        current_fibonacci_number = new_fibonacci_number;
        info!("{}", current_fibonacci_number);
    }
    info!("{}-th fibonacci number = {}", k, current_fibonacci_number);
    info!("written characters = {}", target);
    text.truncate(current_fibonacci_number);
    text
}

#[test]
fn test_fibonacci_word() {
    assert_eq!(b"a", fibonacci_word(0).as_slice());
    assert_eq!(b"ab", fibonacci_word(1).as_slice());
    assert_eq!(b"aba", fibonacci_word(2).as_slice());
    assert_eq!(b"abaab", fibonacci_word(3).as_slice());
    assert_eq!(b"abaababa", fibonacci_word(4).as_slice());
    assert_eq!(b"abaababaabaab", fibonacci_word(5).as_slice());
    assert_eq!(b"abaababaabaababaababa", fibonacci_word(6).as_slice());
}
#[test]
fn test_fibonacci_number() {
    assert_eq!(1, fibonacci_number(0));
    assert_eq!(2, fibonacci_number(1));
    assert_eq!(3, fibonacci_number(2));
    assert_eq!(5, fibonacci_number(3));
    assert_eq!(8, fibonacci_number(4));
    assert_eq!(13, fibonacci_number(5));
    assert_eq!(21, fibonacci_number(6));
    assert_eq!(34, fibonacci_number(7));
    assert_eq!(55, fibonacci_number(8));
    assert_eq!(89, fibonacci_number(9));
    assert_eq!(144, fibonacci_number(10));
    for k in 0..16 {
        assert_eq!(fibonacci_word(k).len(), fibonacci_number(k));
    }
}

/// algorithm computing the i-th Thue-Morse sequence
/// https://oeis.org/A010060
/// It uses the fact that
/// a) TM_k = TM_k-1 \bar{TM_k-1}
/// b) TM_k is a prefix of TM_{k+1}
pub fn thuemorse_word(k: u8) -> Vec<u8> {
    let n = 1 << k;
    let mut text = vec![0_u8; n];
    // let mut text : Vec<u8> = Vec::with_capacity(n);
    // unsafe { text.set_len(n); }
    text[0] = CHR_A;
    for j in 0..k {
        let powerj = 1 << j;
        for k in 0..powerj {
            text[powerj + k] = if text[k] == CHR_A { CHR_B } else { CHR_A };
        }
    }
    text
}

#[test]
fn test_thuemorse_word() {
    assert_eq!(b"a", thuemorse_word(0).as_slice());
    assert_eq!(b"ab", thuemorse_word(1).as_slice());
    assert_eq!(b"abba", thuemorse_word(2).as_slice());
    assert_eq!(b"abbabaab", thuemorse_word(3).as_slice());
    assert_eq!(b"abbabaabbaababba", thuemorse_word(4).as_slice());
}

/// upper bound on the length of the k-th kolakoski word
fn kolakoski_length_estimate(k: u8) -> f64 {
    (2.0f64).powi(k as i32)
}

/// Computes the k-th Kolakoski word starting with 22
/// https://oeis.org/A078880
pub fn kolakoski_word(k: u8) -> Vec<u8> {
    let length = (kolakoski_length_estimate(k + 2) + 1.0) as usize + 1;
    let mut text = vec![0_u8; length];
    // let mut text : Vec<u8> = Vec::with_capacity(length);
    // unsafe { text.set_len(length); }
    info!("allocate text length = {}", length);
    text[0] = CHR_B;
    text[1] = CHR_B;

    // let mut previous_number = 2;
    // let mut current_number = 1; //@ stores in the end the k-th Fibonacci number
    let mut source = 1; //@ pointer in `text` where to read the next input character
    let mut target = 2; //@ pointer in text where to write the next output character
    let mut current_size = 2;
    let mut old_size = 0;

    for _ in 0..k {
        //@ counts for each fibonacci number
        loop {
            let current_symbol = if text[target - 1] == CHR_A {
                CHR_B
            } else {
                CHR_A
            };
            if text[source] == CHR_A {
                text[target] = current_symbol;
                target += 1;
            }
            if text[source] == CHR_B {
                text[target] = current_symbol;
                text[target + 1] = current_symbol;
                target += 2;
            }
            source += 1;
            if source == current_size {
                current_size = old_size + target;
                old_size = current_size - target;
                break;
            }
        }
    }
    unsafe {
        text.set_len(target);
    }
    text
}

#[test]
fn test_kolakoski() {
    // from https://oeis.org/A078880
    let prefix = [
        CHR_B, CHR_B, CHR_A, CHR_A, CHR_B, CHR_A, CHR_B, CHR_B, CHR_A, CHR_B, CHR_B, CHR_A, CHR_A,
        CHR_B, CHR_A, CHR_A, CHR_B, CHR_B, CHR_A, CHR_B, CHR_A, CHR_A, CHR_B, CHR_A, CHR_B, CHR_B,
        CHR_A, CHR_A, CHR_B, CHR_A, CHR_A, CHR_B, CHR_A, CHR_B, CHR_B, CHR_A, CHR_B, CHR_B, CHR_A,
        CHR_A, CHR_B, CHR_A, CHR_B, CHR_B, CHR_A, CHR_B, CHR_A, CHR_A, CHR_B, CHR_A, CHR_A, CHR_B,
        CHR_B, CHR_A, CHR_B, CHR_B, CHR_A, CHR_A, CHR_B, CHR_A, CHR_B, CHR_B, CHR_A, CHR_B, CHR_B,
        CHR_A, CHR_A, CHR_B, CHR_A, CHR_A, CHR_B, CHR_A, CHR_B, CHR_B, CHR_A, CHR_B, CHR_A, CHR_A,
        CHR_B, CHR_B, CHR_A, CHR_B, CHR_B, CHR_A, CHR_A, CHR_B, CHR_A, CHR_B, CHR_B, CHR_A, CHR_B,
        CHR_B, CHR_A, CHR_A, CHR_B, CHR_A, CHR_A, CHR_B, CHR_B, CHR_A, CHR_B, CHR_A, CHR_A, CHR_B,
        CHR_A,
    ];

    for i in 0.. {
        let s = kolakoski_word(i);
        if s.len() > prefix.len() {
            break;
        }
        assert_eq!(s.as_slice(), &prefix[0..s.len()]);
    }
}

static STR_AB: &[u8] = &[CHR_A, CHR_B];
static STR_AAB: &[u8] = &[CHR_A, CHR_A, CHR_B];
static STR_AA: &[u8] = &[CHR_A, CHR_A];
static STR_BA: &[u8] = &[CHR_B, CHR_A];

/// morphism for the Period-doubling sequence
/// https://oeis.org/A096268
fn period_doubling_morphism(c: u8) -> &'static [u8] {
    match c {
        CHR_A => STR_AB,
        _ => STR_AA,
    }
}

pub fn thuemorse_morphism(c: u8) -> &'static [u8] {
    match c {
        CHR_A => STR_AB,
        _ => STR_BA,
    }
}

pub fn fibonacci_morphism(c: u8) -> &'static [u8] {
    match c {
        CHR_A => STR_AB,
        _ => &[CHR_A],
    }
}

/// only works when the morphism is a 2-morphism, meaning that it always maps a character to a
/// string of length two
/// we assume that morphism(a) has a as a prefix.
fn iterate_2morphism(rounds: u8, morphism: fn(u8) -> &'static [u8]) -> Vec<u8> {
    if rounds == 0 {
        return vec![CHR_A];
    }
    let n = 1 << (rounds);
    let mut text = vec![0_u8; n];
    // let mut text : Vec<u8> = Vec::with_capacity(n);
    // unsafe { text.set_len(n); }
    text[0] = CHR_A;
    text[1] = CHR_B;
    let mut source_pos = 1;
    let mut target_pos = 2;
    while target_pos < n {
        for c in morphism(text[source_pos]) {
            text[target_pos] = *c;
            target_pos += 1;
            if target_pos == n {
                break;
            }
        }
        source_pos += 1;
    }
    text
}

// /// for a general morphism where the k-th word is not a prefix of the (k+1)-st word, we need a
// /// slower algorithm that iteratively allocates a larger text
// fn iterate_prefix_morphism_with_startsymbol(
//     rounds: u8,
//     morphism: fn(u8) -> &'static [u8],
//     sizehint: usize,
// 	startsymbol: &[u8]
// ) -> Vec<u8> {
//     if rounds == 0 {
//         return startsymbol.to_vec();
//     }
//     let mut text: Vec<u8> = Vec::with_capacity(if sizehint > 0 { sizehint } else { 1 << rounds });
//     let mut round = 1;
//     for start_char in startsymbol {
//         for c in morphism(*start_char) {
//             text.push(*c);
//         }
//     }
//     let mut end_last_round = text.len() - 1;
//     let mut source_pos = 1;
//     while round < rounds {
//         for c in morphism(text[source_pos]) {
//             text.push(*c);
//         }
//         // println!("text={:?} source_pos={} morphism={:?} round={} end_last_round={}", text, source_pos, morphism(text[source_pos]), round, end_last_round);
//         if source_pos == end_last_round {
//             round += 1;
//             end_last_round = text.len() - 1;
//         }
//         source_pos += 1;
//     }
//     text
// }

/// for a general morphism where the k-th word is not a prefix of the (k-1)-st word, we need a
/// slower algorithm that iteratively allocates a larger text
fn iterate_general_morphism_with_startsymbol(
    rounds: u8,
    morphism: fn(u8) -> &'static [u8],
    sizehint: usize,
    startsymbol: &[u8],
) -> Vec<u8> {
    let mut oldtext: Vec<u8> = startsymbol.to_vec();
    let mut text: Vec<u8> = Vec::with_capacity(if sizehint > 0 { sizehint } else { 1 << rounds });
    for _ in 0..rounds {
        for start_char in oldtext {
            for c in morphism(start_char) {
                text.push(*c);
            }
        }
        oldtext = text;
        text = Vec::new()
    }
    oldtext
}

/// we assume that morphism(a) has a as a prefix, and that the k-th word is a prefix of the
/// (k+1)-st word
/// if sizehint > 0, we assume that the sequence to compute fits into this size
fn iterate_general_morphism(
    rounds: u8,
    morphism: fn(u8) -> &'static [u8],
    sizehint: usize,
) -> Vec<u8> {
    if rounds == 0 {
        return vec![CHR_A];
    }
    let mut text: Vec<u8> = Vec::with_capacity(if sizehint > 0 { sizehint } else { 1 << rounds });
    let mut round = 1;
    for c in morphism(CHR_A) {
        text.push(*c);
    }
    let mut end_last_round = text.len() - 1;
    let mut source_pos = 1;
    while round < rounds {
        for c in morphism(text[source_pos]) {
            text.push(*c);
        }
        // println!("text={:?} source_pos={} morphism={:?} round={} end_last_round={}", text, source_pos, morphism(text[source_pos]), round, end_last_round);
        if source_pos == end_last_round {
            round += 1;
            end_last_round = text.len() - 1;
        }
        source_pos += 1;
    }
    text
}

pub fn period_doubling_word(k: u8) -> Vec<u8> {
    iterate_2morphism(k, period_doubling_morphism)
}

#[test]
fn test_thue_morse_morphism() {
    for k in 0..10 {
        assert_eq!(
            thuemorse_word(k),
            iterate_2morphism(k, thuemorse_morphism).as_slice()
        );
    }
}

#[test]
fn test_fibonacci_morphism() {
    for k in 0..10 {
        assert_eq!(
            fibonacci_word(k),
            iterate_general_morphism(k, fibonacci_morphism, fibonacci_number(k)).as_slice()
        );
    }
}

#[test]
fn test_perioddoubling() {
    assert_eq!(
        b"a",
        iterate_2morphism(0, period_doubling_morphism).as_slice()
    );
    assert_eq!(
        b"ab",
        iterate_2morphism(1, period_doubling_morphism).as_slice()
    );
    assert_eq!(
        b"abaa",
        iterate_2morphism(2, period_doubling_morphism).as_slice()
    );
    assert_eq!(
        b"abaaabab",
        iterate_2morphism(3, period_doubling_morphism).as_slice()
    );
    assert_eq!(
        b"abaaabababaaabaa",
        iterate_2morphism(4, period_doubling_morphism).as_slice()
    );
    assert_eq!(
        b"abaaabababaaabaaabaaabababaaabab",
        iterate_2morphism(5, period_doubling_morphism).as_slice()
    );
}

const CHR_C: u8 = b'c';
const CHR_D: u8 = b'd';

const CHR_ZERO: u8 = b'0';
const CHR_ONE: u8 = b'1';

pub fn paperfolding_word(i: u8) -> Vec<u8> {
    quaternary_to_binary(&quaternary_paperfolding_word(i))
}

/// algorithm computing the i-th paperfolding sequence
/// https://oeis.org/A014577
/// where a = 00, b = 01, c = 10, d = 11
pub fn quaternary_paperfolding_word(i: u8) -> Vec<u8> {
    let n = 1 << i;
    let mut text = vec![0_u8; n];
    // let mut text : Vec<u8> = Vec::with_capacity(n);
    // unsafe { text.set_len(n); }
    text[0] = CHR_D;

    for k in 0..(n >> 1) {
        let target_position = 2 * k;
        match text[k] {
            CHR_D => {
                text[target_position] = CHR_D;
                text[target_position + 1] = CHR_B;
            }
            CHR_B => {
                text[target_position] = CHR_C;
                text[target_position + 1] = CHR_B;
            }
            CHR_C => {
                text[target_position] = CHR_D;
                text[target_position + 1] = CHR_A;
            }
            CHR_A => {
                text[target_position] = CHR_C;
                text[target_position + 1] = CHR_A;
            }
            _ => panic!("unknown sequence : {} at position {}", text[k], k),
        }
    }
    text
}

#[test]
fn test_paperfolding() {
    assert_eq!(b"d", quaternary_paperfolding_word(0).as_slice());
    assert_eq!(b"db", quaternary_paperfolding_word(1).as_slice());
    assert_eq!(b"dbcb", quaternary_paperfolding_word(2).as_slice());
    assert_eq!(b"dbcbdacb", quaternary_paperfolding_word(3).as_slice());

    let mut l = paperfolding_word(10);
    l.resize(99, 0);
    assert_eq!(b"110110011100100111011000110010011101100111001000110110001100100111011001110010011101100011001000110", l.as_slice());
    // [0..100] );
}

fn quaternary_to_binary(text: &[u8]) -> Vec<u8> {
    let n = text.len() << 1;
    let mut output = vec![0_u8; n];
    // let mut output : Vec<u8> = Vec::with_capacity(n);
    // unsafe { output.set_len(n); }
    for i in 0..text.len() {
        match text[i] {
            CHR_D => {
                output[2 * i] = CHR_ONE;
                output[2 * i + 1] = CHR_ONE;
            }
            CHR_B => {
                output[2 * i] = CHR_ZERO;
                output[2 * i + 1] = CHR_ONE;
            }
            CHR_C => {
                output[2 * i] = CHR_ONE;
                output[2 * i + 1] = CHR_ZERO;
            }
            CHR_A => {
                output[2 * i] = CHR_ZERO;
                output[2 * i + 1] = CHR_ZERO;
            }
            _ => panic!("unknown sequence : {} at position {}", text[i], i),
        }
    }
    output
}

/// checks whether T[1..n] is a necklace, i.e., the lexicographically smallest string among all its
/// shifted conjugates of the form T[i+1..n]T[1..i]
pub fn is_necklace<T>(text: &T, n: usize) -> bool
where
    T: ?Sized + std::ops::Index<usize, Output = u8>,
{
    // let n = text.len();
    let mut i = 0;
    let mut j = 1;
    while j != n && text.index(i) <= text.index(j) {
        if text.index(i) < text.index(j) {
            i = 0;
        }
        if text.index(i) == text.index(j) {
            i += 1;
        }
        j += 1;
    }
    if j != n {
        return false;
    }
    true
}

#[allow(dead_code)]
fn is_necklace_slice(text: &[u8]) -> bool {
    is_necklace(text, text.len())
}

#[test]
fn test_is_necklace() {
    assert!(is_necklace_slice(b"a"));
    assert!(is_necklace_slice(b"aa"));
    assert!(is_necklace_slice(b"ab"));
    assert!(is_necklace_slice(b"aaa"));
    assert!(is_necklace_slice(b"aba"));
    assert!(is_necklace_slice(b"aaba"));
    assert!(is_necklace_slice(b"abab"));
    assert!(is_necklace_slice(b"ababa"));
    assert!(!is_necklace_slice(b"ba"));
    assert!(!is_necklace_slice(b"bab"));
    assert!(!is_necklace_slice(b"bba"));
    assert!(!is_necklace_slice(b"bbba"));
}

fn reverse(c: u8) -> u8 {
    if c == CHR_A {
        CHR_B
    } else {
        CHR_A
    }
}

/// Online construction algorithm of
/// J. Sawada, A. Williams and D. Wong. A surprisingly simple de Bruijn sequence
/// construction. Discrete Math., 339(1):127--131, 2016.
pub fn binary_debruijn_word(k: u8) -> Vec<u8> {
    use std::collections::VecDeque;
    let n = k as usize + 1;
    let mut word: VecDeque<u8> = VecDeque::with_capacity(n);
    for _ in 0..n {
        word.push_back(CHR_A);
    }
    let mut output: Vec<u8> = Vec::with_capacity(n);
    loop {
        let mut first_char = word.pop_front().unwrap();
        word.push_back(CHR_B);
        if is_necklace(&word, word.len()) {
            first_char = reverse(first_char);
        }
        *word.back_mut().unwrap() = first_char;
        output.push(first_char);
        for (i, letter) in word.iter().enumerate().take(n) {
            if *letter == CHR_B {
                break;
            }
            if i == n - 1 {
                return output;
            }
        }
    }
}

/// The k-th binary de-Brujin sequence has a length of 2^{k+1}, and each substring of length k+1 is
/// has a nuique occurrence
#[test]
fn test_binary_debrujin_word() {
    use std::str;

    for k in 2..10 {
        let word = binary_debruijn_word(k);
        let text = str::from_utf8(&word).unwrap();
        for pos in 0..word.len() - k as usize {
            let pattern = str::from_utf8(&word[pos..pos + 1 + k as usize]).unwrap();
            assert!(text[pos + 1..].find(pattern) == None);
        }
    }
}

/// characteristic sequence c of the powers of 2
/// https://arxiv.org/pdf/2206.00376.pdf
/// https://arxiv.org/pdf/2012.06840.pdf
/// is https://oeis.org/A209229 and
/// resembles https://oeis.org/A267366
pub fn power2_sequence(k: u8) -> Vec<u8> {
    let n = 1 << k;
    let mut text = vec![0_u8; n];
    // let mut text : Vec<u8> = Vec::with_capacity(n);
    // unsafe { text.set_len(n); }
    let mut most_significant_bit = 0;
    for j in 1..n {
        while j > 1 << (most_significant_bit + 1) {
            most_significant_bit += 1;
        }
        if j & ((1 << most_significant_bit) - 1) > 0 {
            text[j - 1] = CHR_A;
        } else {
            text[j - 1] = CHR_B;
        }
    }
    text
}

static STR_AC: &[u8] = &[CHR_A, CHR_C];

pub fn tribonacci_morphism(c: u8) -> &'static [u8] {
    match c {
        CHR_A => STR_AB,
        CHR_B => STR_AC,
        _ => &[CHR_A],
    }
}

pub fn tribonacci_word(k: u8) -> Vec<u8> {
    iterate_general_morphism(k, tribonacci_morphism, tribonacci_number(k))
}

#[test]
fn test_tribonacci() {
    assert_eq!(b"a", tribonacci_word(0).as_slice());
    assert_eq!(b"ab", tribonacci_word(1).as_slice());
    assert_eq!(b"abac", tribonacci_word(2).as_slice());
    assert_eq!(b"abacaba", tribonacci_word(3).as_slice());
    assert_eq!(b"abacabaabacab", tribonacci_word(4).as_slice());
    assert_eq!(b"abacabaabacababacabaabac", tribonacci_word(5).as_slice());
    assert_eq!(
        b"abacabaabacababacabaabacabacabaabacababacaba",
        tribonacci_word(6).as_slice()
    );
}

pub fn tribonacci_number(k: u8) -> usize {
    if k == 0 {
        return 1;
    }

    let [mut sum, mut cur, mut old, mut ancient] = [0, 1, 1, 0];
    for _ in 0..k {
        sum = cur + old + ancient;
        ancient = old;
        old = cur;
        cur = sum;
    }
    sum
}

#[test]
fn test_tribonacci_number() {
    assert_eq!(1, tribonacci_number(0));
    assert_eq!(2, tribonacci_number(1));
    assert_eq!(4, tribonacci_number(2));
    assert_eq!(7, tribonacci_number(3));
    assert_eq!(13, tribonacci_number(4));
    assert_eq!(24, tribonacci_number(5));
    assert_eq!(44, tribonacci_number(6));
    assert_eq!(81, tribonacci_number(7));
    assert_eq!(149, tribonacci_number(8));
    assert_eq!(274, tribonacci_number(9));
    assert_eq!(504, tribonacci_number(10));
    for k in 0..16 {
        assert_eq!(tribonacci_word(k).len(), tribonacci_number(k));
    }
}

static STR_ABC: &[u8] = &[CHR_A, CHR_B, CHR_C];
pub fn vtm_morphism(c: u8) -> &'static [u8] {
    match c {
        CHR_A => STR_ABC,
        CHR_B => STR_AC,
        _ => &[CHR_B],
    }
}

/// A Thue-Morse variant studied in
/// Francine Blanchet-Sadri, James D. Currie, Narad Rampersad, Nathan Fox:
/// Abelian Complexity of Fixed Point of Morphism 0 ↦ 012, 1 ↦ 02, 2 ↦ 1. Integers 14: A11 (2014)
pub fn vtm_word(k: u8) -> Vec<u8> {
    iterate_general_morphism(k, vtm_morphism, (1 + (3 << (k))) as usize)
}

#[test]
fn test_vtm() {
    // assert_eq!(b"a"                     , vtm_word(0).as_slice());
    // assert_eq!(b"abc"                    , vtm_word(1).as_slice());
    assert_eq!(b"abcacb", vtm_word(2).as_slice());
    assert_eq!(b"abcacbabcbac", vtm_word(3).as_slice());
    assert_eq!(b"abcacbabcbacabcacbacabcb", vtm_word(4).as_slice());
}

pub fn fibonacci_lyndonfactor_morphism(c: u8) -> &'static [u8] {
    match c {
        CHR_A => STR_AAB,
        _ => STR_AB,
    }
}

/// The k-th Lyndon factor of the infinite Fibonacci word
/// Guy Melançon:
/// Lyndon Words and Singular Factors of Sturmian Words. Theor. Comput. Sci. 218(1): 41-59 (1999)
/// Proposition 2.8
pub fn fibonacci_lyndonfactor(k: u8) -> Vec<u8> {
    iterate_general_morphism_with_startsymbol(
        k,
        fibonacci_lyndonfactor_morphism,
        (1 + (3 << (k))) as usize,
        STR_AB,
    )
}

#[test]
fn test_fibonacci_lyndonfactor() {
    assert_eq!(b"ab", fibonacci_lyndonfactor(0).as_slice());
    assert_eq!(b"aabab", fibonacci_lyndonfactor(1).as_slice());
    assert_eq!(b"aabaababaabab", fibonacci_lyndonfactor(2).as_slice());
}
