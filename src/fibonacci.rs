extern crate env_logger;
extern crate log;
use log::info;

const CHR_A : u8 = 'a' as u8;
const CHR_B : u8 = 'b' as u8;

const SQRT_5 : f64 = 2.23606797749978969641; //(5.0 as f64).sqrt();
const GOLDEN_RATIO : f64 = (1.0 + SQRT_5)/2.0;
const PSI : f64 = - 1.0/GOLDEN_RATIO;


pub fn fibonacci_number(n: u8) -> usize {
	// if n == 0 {
	// 	return 1;
	// }

	let [mut sum, mut cur, mut old] = [1,1,0];
	// let mut last = 0;
	// let mut curr = 1;
	for _ in 0..n {
        sum = cur + old;
        old = cur;
        cur = sum;
	}
	sum
}

/// Estimates the k-th Fibonacci number with Binet's formula
fn fibonacci_number_estimate(k : u8) -> f64 {
    (GOLDEN_RATIO.powi(k as i32) - PSI.powi(k as i32))/SQRT_5
}

/// Computes the k-th Fibonacci word
/// https://oeis.org/A003849
/// Reference: Patrice Séébold: "Sequences generated by infinitely iterated morphisms". Discret. Appl. Math. 11(3): 255-264 (1985)
pub fn fibonacci(k : u8) -> Vec<u8> {
    let length = (fibonacci_number_estimate(k+1)+1.0) as usize + 1;
    let mut text : Vec<u8> = Vec::with_capacity(length);
    unsafe { text.set_len(length); }
    info!("allocate text length = {}", length);
    text[0] = CHR_A;

    let mut previous_fibonacci_number = 0;
    let mut current_fibonacci_number = 1; //@ stores in the end the k-th Fibonacci number
    let mut source = 0; //@ pointer in `text` where to read the next input character
    let mut target = 1; //@ pointer in text where to write the next output character

    for _ in 0..k { //@ counts for each fibonacci number
        let new_fibonacci_number = current_fibonacci_number + previous_fibonacci_number;
        while target < new_fibonacci_number {
            if text[source] == CHR_A {
                text[target] = CHR_B;
                text[target+1] = CHR_A;
                target += 2;
            } else {
                text[target] = CHR_A;
                target += 1;
            }
            source += 1;
        }
        previous_fibonacci_number = current_fibonacci_number;
        current_fibonacci_number = new_fibonacci_number;
        info!("{}", current_fibonacci_number);
    }
    info!("{}-th fibonacci number = {}", k, current_fibonacci_number);
    info!("written characters = {}", target);
    text.truncate(current_fibonacci_number);
    return text
}

#[test]
fn test_fibonacci() {
    assert_eq!(b"a"                     , fibonacci(1).as_slice());
    assert_eq!(b"ab"                    , fibonacci(2).as_slice());
    assert_eq!(b"aba"                   , fibonacci(3).as_slice());
    assert_eq!(b"abaab"                 , fibonacci(4).as_slice());
    assert_eq!(b"abaababa"              , fibonacci(5).as_slice());
    assert_eq!(b"abaababaabaab"         , fibonacci(6).as_slice());
    assert_eq!(b"abaababaabaababaababa" , fibonacci(7).as_slice());
}
#[test]
fn test_fibonacci_number() {
    assert_eq!(1, fibonacci_number(0));
    assert_eq!(1, fibonacci_number(1));
    assert_eq!(2, fibonacci_number(2));
    assert_eq!(3, fibonacci_number(3));
    assert_eq!(5, fibonacci_number(4));
    assert_eq!(8, fibonacci_number(5));
    assert_eq!(13,fibonacci_number(6));
    assert_eq!(21,fibonacci_number(7));
    assert_eq!(34,fibonacci_number(8));
    assert_eq!(55,fibonacci_number(9));
    assert_eq!(89,fibonacci_number(10));
    assert_eq!(144,fibonacci_number(11));
    for k in 0..16 {
        assert_eq!(fibonacci(k).len(), fibonacci_number(k));
    }
}



fn main() {
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 2 {
        eprintln!("prints the k-th Fibonacci word\nUsage: {} [number k >= 0]", args[0]);
        std::process::exit(1);
    }
    env_logger::init();

    let index : u8 = args[1].parse::<u8>().unwrap() + 1u8;
    use std::io::Write;
    std::io::stdout().write_all(fibonacci(index).as_slice()).unwrap();
}

